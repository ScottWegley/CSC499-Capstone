<script lang="ts">
	import {
		Heading,
		P,
		ButtonGroup,
		CheckboxButton,
		FloatingLabelInput,
		Range,
		Label,
		Button,
		Alert,
		Tooltip
	} from 'flowbite-svelte';
	import { InfoCircleSolid } from 'flowbite-svelte-icons';

	/** This specifies how long the generated passoword is. */
	let demoPasswordLength = 12;
	/** This is the minimum length of the password. */
	let demoPassMin = 1;
	/** This is the maximum length of the password. */
	let demoPassMax = 64;
	/** This boolean represents whether or not uppercase letters are included in the password. */
	let demoUppercase = false;
	/** This boolean represents whether or not lowercase letters are included in the password. */
	let demoLowercase = false;
	/** This boolean represents whether or not numbers are included in the password. */
	let demoNumbers = false;
	/** This boolean represents whether or not special characters are included in the password. */
	let demoSpecial = false;

	/** This is the number of letters in the upper/lowercase set. */
	const letterCount = 26; // ABCDEFGHIJKLMNOPQRSTUVWXYZ
	/** This is the number of numbers in the number set. */
	const numCount = 10; //0123456789
	/** This is the number of special characters in the character set. */
	const specialCount = 27; // `~!@#$%^&*()-_=+{}[]|;:?,<>

	/** This represents the number of possible passwords based on the other specified variables. */
	$: demoPassComplexity = Math.pow(
		(demoUppercase ? letterCount : 0) +
			(demoLowercase ? letterCount : 0) +
			(demoNumbers ? numCount : 0) +
			(demoSpecial ? specialCount : 0),
		demoPasswordLength
	);

	/** This is the example password we generate. */
	let demoPassword = '';

	/** This boolean represents whether or not bruteforcing is currently active. */
	let bruteforceActive = false;

	/** This function returns the current characterset based on the selected password rules. */
	function getCurrentCharset() {
		let possibleChars = '';
		if (demoUppercase) {
			possibleChars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
		}
		if (demoLowercase) {
			possibleChars += 'abcdefghijklmnopqrstuvwxyz';
		}
		if (demoNumbers) {
			possibleChars += '0123456789';
		}
		if (demoSpecial) {
			possibleChars += '`~!@#$%^&*()-_=+{}[]|;:?,<>';
		}
		return possibleChars;
	}

	/** This function gnerate a random password based on the selected rules and length. */
	function generateSamplePassword() {
		let possibleChars = getCurrentCharset();
		let password = '';

		for (let i = 0; i < demoPasswordLength; i++) {
			password += possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));
		}

		demoPassword = password;

		return password;
	}

	/** This boolean represents whether or not a benchmark has been run. */
	let benchmarkRun = false;
	/** Stores the timestamp for the benchmark starting. */
	let benchmarkStartTime = 0;
	/** Stores the amount of passwords generated by the current benchmark. */
	let benchmarkGenerated = 0;
	/** Stores the benchmark limit for password generation. */
	let benchmarkLimit = 20000;
	/** Stores the timestamp for the benchmark ending. */
	let benchmarkEndTime = 0;

	/** This functions starts a benchmark to calculate how long it will take to generate 10,000 passwords based on the current ruleset. */
	async function startBenchmark() {
		console.log('Starting benchmark.');
		// Reset the benchmark tracking variables.
		benchmarkStartTime = Date.now();
		benchmarkEndTime = Date.now();
		benchmarkGenerated = 0;
		benchmarkRun = false;

		let possibleChars = getCurrentCharset();
		await incrementPossiblePws(possibleChars, '', possibleChars.length, demoPasswordLength);

		benchmarkEndTime = Date.now();
		benchmarkRun = true;
	}

	/** Inspired by the code and article found here https://www.geeksforgeeks.org/print-all-combinations-of-given-length/ */
	async function incrementPossiblePws(charSet: String, prev: String, n: number, k: number) {
		// If we've reached the end of the benchmark kill all recursion.
		if (benchmarkGenerated >= benchmarkLimit) {
			return;
		}

		// If this branch of recursion has reached the desired length, simulate the comparison, increase the count.
		if (k == 0) {
			if (prev != '   ') {
				benchmarkGenerated += 1;
				return;
			}
		}

		// Add every possible character and take a step further into the iterations.
		for (let i = 0; i < n; i++) {
			await incrementPossiblePws(charSet, prev + charSet.charAt(i), n, k - 1);
		}
	}

	/** This boolean represents whether or not bruteforcing has been cancelled. */
	let bruteForceCancelled = false;
	/** This represents the number of passwords generated by the bruteforce search. */
	let bruteForceGenerated = 0;

	async function iterateBruteforce(charSet: String, prev: String, n: number, k: number) {
		// If this branch of recursion has reached the desired length, increase the count, check for match, prune the branch.
		if (k == 0) {
			bruteForceGenerated += 1;
			if (prev == demoPassword) {
				bruteForceCancelled = true;
			}
			return;
		}

		// Add every possible character and take a step further into the iterations.
		for (let i = 0; i < n; i++) {
			await iterateBruteforce(charSet, prev + charSet.charAt(i), n, k - 1);
		}
	}
</script>

<title>Password Tool</title>

<div class="text-center">
	<Heading tag="h2" class="mb-4">Password Tool</Heading>
	<P class="mb-6 text-lg dark:text-gray-400 sm:px-16" align="center" size="sm">
		Passwords are a part of every day life and are used to guard information that is important.
		Given the value of the information we hide behind passwords, it's important to make sure our
		passwords are up to a standard so that malicious actors can't determine them. This tool
		calculates how complex any given password is and gives you an idea of how long it would take to
		break.
	</P>
	<div class="inline-block items-center justify-center text-left">
		<FloatingLabelInput size="small" disabled
			>Total Possible Passwords: {demoPassComplexity}
		</FloatingLabelInput>
		<ButtonGroup class="mb-3 mt-3">
			<CheckboxButton bind:checked={demoUppercase}>[A-Z] Uppercase Letters</CheckboxButton>
			<CheckboxButton bind:checked={demoLowercase}>[a-z] Lowercase Letters</CheckboxButton>
			<CheckboxButton bind:checked={demoNumbers}>[0-9] Numbers</CheckboxButton>
			<CheckboxButton bind:checked={demoSpecial}>[!#?] Special Characters</CheckboxButton>
		</ButtonGroup>
		<Button
			outline
			color="blue"
			on:click={(e) => {
				generateSamplePassword();
			}}>Generate Sample Password</Button
		>
		<Label>Length: {demoPasswordLength}</Label>
		<Range bind:value={demoPasswordLength} min={demoPassMin} max={demoPassMax} />
	</div>
	<div class="mx-auto max-w-screen-lg">
		<P class="mb-6 text-lg dark:text-gray-400 sm:px-16" align="center" size="sm">
			If your passwords are completely random, one of the only remaining vulnerabitilities is brute
			force attacks. To prevent this, use complex passwords. Lets see how secure you are with your
			selected password rules.
		</P>
	</div>
	<div class="inline-block items-center justify-center text-center">
		<Label class="min">
			Your Password: {demoPassword}
		</Label>
		<ButtonGroup class="mb-3 mt-3">
			<Button
				outline
				color="blue"
				on:click={(e) => {
					startBenchmark();
				}}
			>
				Run Benchmark
			</Button>
			<Button id="bruteforceBtn" outline color={bruteforceActive ? 'red' : 'blue'} disabled='{demoPassword==''}' on:click={(e) => {}}>
				{bruteforceActive ? 'Stop' : 'Start'} Bruteforce
			</Button>
			{#if demoPassword==''}
				<Tooltip triggeredBy="[id=bruteforceBtn]">
					Generate a password before bruteforcing.
				</Tooltip>
			{/if}
		</ButtonGroup>
	</div>
	<!-- The elements enclosed below should only be visible if a benchmark has been run. -->
	{#if true}
		<div class="mx-auto w-fit">
			<Alert color="green" class="w-fit">
				<InfoCircleSolid slot="icon" class="h-4 w-4" />
				Your computer was able to generate and test {benchmarkGenerated} passwords in {benchmarkEndTime -
					benchmarkStartTime} milliseconds.
			</Alert>
		</div>
		<div class="mx-auto w-fit">
			<P class="mb-6 w-fit text-lg dark:text-gray-400 sm:px-16" align="center"
				>With those results, your computer would take around {(demoPassComplexity /
					benchmarkLimit) *
					(benchmarkEndTime - benchmarkStartTime)} milliseconds [{((demoPassComplexity /
					benchmarkLimit) *
					(benchmarkEndTime - benchmarkStartTime)) /
					86400000} days] to bruteforce your password. While obviously a dedicated password cracking
				machine would outperform your web browser, as you mess around with the settings it should be
				clear that with the exponentially increasing amount of possible passwords, the time to bruteforce
				also exponentially increases.</P
			>
		</div>
	{/if}
</div>

<style>
</style>
