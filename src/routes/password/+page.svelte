<script lang="ts">
	import {
		Heading,
		P,
		ButtonGroup,
		CheckboxButton,
		FloatingLabelInput,
		Range,
		Label,
		Button,
		Alert,
		Tooltip
	} from 'flowbite-svelte';
	import { InfoCircleSolid } from 'flowbite-svelte-icons';

	// #region Demonstration Password Details
	/** This specifies how long the generated passoword is. */
	let demoPasswordLength = 12;
	/** This is the minimum length of the password. */
	let demoPassMin = 1;
	/** This is the maximum length of the password. */
	let demoPassMax = 64;
	/** This boolean represents whether or not uppercase letters are included in the password. */
	let demoUppercase = false;
	/** This boolean represents whether or not lowercase letters are included in the password. */
	let demoLowercase = false;
	/** This boolean represents whether or not numbers are included in the password. */
	let demoNumbers = false;
	/** This boolean represents whether or not special characters are included in the password. */
	let demoSpecial = false;

	/** This is the number of letters in the upper/lowercase set. */
	const letterCount = 26; // ABCDEFGHIJKLMNOPQRSTUVWXYZ
	/** This is the number of numbers in the number set. */
	const numCount = 10; //0123456789
	/** This is the number of special characters in the character set. */
	const specialCount = 27; // `~!@#$%^&*()-_=+{}[]|;:?,<>

	/** This represents the number of possible passwords based on the other specified variables. */
	$: demoPassComplexity = Math.pow(
		(demoUppercase ? letterCount : 0) +
			(demoLowercase ? letterCount : 0) +
			(demoNumbers ? numCount : 0) +
			(demoSpecial ? specialCount : 0),
		demoPasswordLength
	);

	/** This is the example password we generate. */
	let demoPassword = '';
	// #endregion

	// #region Demonstration Password Generation Functions
	/** This function returns the current characterset based on the selected password rules. */
	function getCurrentCharset() {
		let possibleChars = '';
		if (demoUppercase) {
			possibleChars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
		}
		if (demoLowercase) {
			possibleChars += 'abcdefghijklmnopqrstuvwxyz';
		}
		if (demoNumbers) {
			possibleChars += '0123456789';
		}
		if (demoSpecial) {
			possibleChars += '`~!@#$%^&*()-_=+{}[]|;:?,<>';
		}
		return possibleChars;
	}

	let gennedCharset = '';

	/** This function generate a random password based on the selected rules and length. */
	function generateSamplePassword() {
		bruteForceRun = false;
		let possibleChars = getCurrentCharset();
		let password = '';

		for (let i = 0; i < demoPasswordLength; i++) {
			password += possibleChars.charAt(Math.floor(Math.random() * possibleChars.length));
		}

		demoPassword = password;

		gennedPasswordLength = demoPasswordLength;
		gennedCharset = possibleChars;

		return password;
	}
	// #endregion

	// #region Benchmarking Variables and Functions
	/** This boolean represents whether or not a benchmark has been run. */
	let benchmarkRun = false;
	/** Stores the timestamp for the benchmark starting. */
	let benchmarkStartTime = 0;
	/** Stores the amount of passwords generated by the current benchmark. */
	let benchmarkGenerated = 0;
	/** Stores the benchmark limit for password generation. */
	let benchmarkLimit = 100000;
	/** Stores the timestamp for the benchmark ending. */
	let benchmarkEndTime = 0;

	let gennedPasswordLength = 0;

	/** This value represents the total amount of time, in milliseconds, a benchmark took to run. */
	$: benchmarkTotalTime = benchmarkEndTime - benchmarkStartTime;
	/** This values represents how many benchmarks' worth of iterations are in the full range of possible passwords. */
	$: demoToBenchmarkRatio = demoPassComplexity / benchmarkLimit;
	/** This value represents the predicted total milliseconds to run a full bruteforce based on the benchmark. */
	$: predictedTotalMilliseconds = demoToBenchmarkRatio * benchmarkTotalTime;
	/** This value stores the relevant unit of time to share our prediction with the user.*/
	$: predictedRelevantTimeStat = getRelevantTimeStat(predictedTotalMilliseconds);

	function getRelevantTimeStat(ms: number) {
		if (ms / 31556952000000 > 1) {
			return (
				parseFloat((ms / 31556952000000).toFixed(2)) +
				' Millenni' +
				(ms / 31556952000000 == 1 ? 'um' : 'a')
			);
		} else if (ms / 3155695200000 > 1) {
			return (
				parseFloat((ms / 3155695200000).toFixed(2)) +
				' Centur' +
				(ms / 3155695200000 == 1 ? 'y' : 'ies')
			);
		} else if (ms / 315569520000 > 1) {
			return (
				parseFloat((ms / 315569520000).toFixed(2)) + ' Decade' + (ms / 315569520000 == 1 ? '' : 's')
			);
		} else if (ms / 31556952000 > 1) {
			return (
				parseFloat((ms / 31556952000).toFixed(2)) + ' Year' + (ms / 31556952000 == 1 ? '' : 's')
			);
		} else if (ms / 2629746000 > 1) {
			return (
				parseFloat((ms / 2629746000).toFixed(2)) + ' Month' + (ms / 2629746000 == 1 ? '' : 's')
			);
		} else if (ms / 604800000 > 1) {
			return parseFloat((ms / 604800000).toFixed(2)) + ' Week' + (ms / 604800000 == 1 ? '' : 's');
		} else if (ms / 86400000 > 1) {
			return parseFloat((ms / 86400000).toFixed(2)) + ' Day' + (ms / 86400000 == 1 ? '' : 's');
		} else if (ms / 3600000 > 1) {
			return parseFloat((ms / 3600000).toFixed(2)) + ' Hour' + (ms / 3600000 == 1 ? '' : 's');
		} else if (ms / 60000 > 1) {
			return parseFloat((ms / 60000).toFixed(2)) + ' Minute' + (ms / 60000 == 1 ? '' : 's');
		} else if (ms / 1000 > 1) {
			return parseFloat((ms / 1000).toFixed(2)) + ' Second' + (ms / 1000 == 1 ? '' : 's');
		} else {
			return parseFloat(ms.toFixed(2)) + ' Millisecond' + (ms == 1 ? '' : 's');
		}
	}

	/** This functions starts a benchmark to calculate how long it will take to generate 10,000 passwords based on the current ruleset. */
	async function startBenchmark() {
		let possibleChars = getCurrentCharset();
		// If no rules are enabled for the password, there are no potential characters, and there is no point in running the benchmark.
		if (possibleChars == '') return;

		// Reset the benchmark tracking variables.
		benchmarkStartTime = Date.now();
		benchmarkEndTime = Date.now();
		benchmarkGenerated = 0;
		benchmarkRun = false;

		await incrementPossiblePws(possibleChars, '', possibleChars.length, demoPasswordLength);

		benchmarkEndTime = Date.now();
		benchmarkRun = true;
	}

	/** Inspired by the code and article found here https://www.geeksforgeeks.org/print-all-combinations-of-given-length/ */
	async function incrementPossiblePws(charSet: String, prev: String, n: number, k: number) {
		// If we've reached the end of the benchmark kill all recursion.
		if (benchmarkGenerated >= benchmarkLimit) {
			return;
		}

		// If this branch of recursion has reached the desired length, simulate the comparison, increase the count.
		if (k == 0) {
			if (prev != '   ') {
				benchmarkGenerated += 1;
				return;
			}
		}

		// Add every possible character and take a step further into the iterations.
		for (let i = 0; i < n; i++) {
			await incrementPossiblePws(charSet, prev + charSet.charAt(i), n, k - 1);
		}
	}
	// #endregion

	// #region Password Bruteforcing Variables & Functions
	/** This boolean represents whether or not bruteforcing has been cancelled. */
	let bruteForceCancelled = false;
	/** This represents the number of passwords generated by the bruteforce search. */
	let bruteForceGenerated = 0;
	/** This boolean represents whether or not a bruteforce has been run. */
	let bruteForceRun = false;
	/** Stores the starting timestamp of a bruteforce run. */
	let bruteForceStartTime = 0;
	/** Stores the ending timestamp of a bruteforce run. */
	let bruteForceEndTime = 0;
	/** This booleans represents whether or not a bruteforce search found a match. */
	let bruteForceMatch = false;
	/** This boolean represents whether or not bruteforcing is currently active. */
	let bruteforceActive = false;

	async function startBruteforce() {
		let possibleChars = gennedCharset;
		// If no rules are enabled for the password, there are no potential characters, and there is no point in running the benchmark.
		if (possibleChars == '') return;

		// Reset bruteforce tracking variables.
		bruteForceCancelled = false;
		bruteForceGenerated = 0;
		bruteForceRun = false;
		bruteForceStartTime = Date.now();
		bruteForceEndTime = Date.now();
		bruteForceMatch = false;

		bruteforceActive = true;
		await iterateBruteforce(possibleChars, '', possibleChars.length, gennedPasswordLength);
		bruteForceEndTime = Date.now();
		bruteForceRun = true;
		bruteforceActive = false;
	}

	async function iterateBruteforce(charSet: String, prev: String, n: number, k: number) {
		if (bruteForceCancelled || bruteForceMatch) {
			bruteforceActive = false;
			return;
		}

		// If this branch of recursion has reached the desired length, increase the count, check for match, prune the branch.
		if (k == 0) {
			bruteForceGenerated += 1;
			if (prev == demoPassword) {
				bruteForceMatch = true;
			}
			return;
		}

		// Add every possible character and take a step further into the iterations.
		for (let i = 0; i < n; i++) {
			await iterateBruteforce(charSet, prev + charSet.charAt(i), n, k - 1);
		}
	}
	// #endregion
</script>

<title>Password Tool</title>

<div class="text-center">
	<Heading tag="h2" class="mb-4">Password Tool</Heading>
	<P class="mb-6 text-lg dark:text-gray-400 sm:px-16" align="center" size="sm">
		Passwords are a part of every day life and are used to guard information that is important.
		Given the value of the information we hide behind passwords, it's important to make sure our
		passwords are up to a standard so that malicious actors can't determine them. This tool
		calculates how complex any given password is and gives you an idea of how long it would take to
		break.
	</P>
	<!-- #region User Interaction for Password Generation -->
	<div class="inline-block items-center justify-center text-left">
		<FloatingLabelInput size="small" disabled
			>Total Possible Passwords: {demoPassComplexity}
		</FloatingLabelInput>
		<ButtonGroup class="mb-3 mt-3">
			<CheckboxButton bind:checked={demoUppercase}>[A-Z] Uppercase Letters</CheckboxButton>
			<CheckboxButton bind:checked={demoLowercase}>[a-z] Lowercase Letters</CheckboxButton>
			<CheckboxButton bind:checked={demoNumbers}>[0-9] Numbers</CheckboxButton>
			<CheckboxButton bind:checked={demoSpecial}>[!#?] Special Characters</CheckboxButton>
		</ButtonGroup>
		<Button
			outline
			color="blue"
			on:click={(e) => {
				generateSamplePassword();
			}}>Generate Sample Password</Button
		>
		<Label>Length: {demoPasswordLength}</Label>
		<Range bind:value={demoPasswordLength} min={demoPassMin} max={demoPassMax} />
	</div>
	<!-- #endregion -->
	<div class="mx-auto max-w-screen-lg">
		<P class="mb-6 text-lg dark:text-gray-400 sm:px-16" align="center" size="sm">
			If your passwords are completely random, one of the only remaining vulnerabitilities is brute
			force attacks. To prevent this, use complex passwords. Lets see how secure you are with your
			selected password rules.
		</P>
	</div>
	<!-- #region Benchmark and Bruteforce Controls -->
	<div class="inline-block items-center justify-center text-center">
		<Label class="min">
			Your Password: {demoPassword}
		</Label>
		<ButtonGroup class="mb-3 mt-3">
			<Button
				outline
				color="blue"
				on:click={(e) => {
					startBenchmark();
				}}
			>
				Run Benchmark
			</Button>
			<Button
				id="bruteforceBtn"
				outline
				color={bruteforceActive ? 'red' : 'blue'}
				disabled={demoPassword == '' || !benchmarkRun}
				on:click={(e) => {
					if (bruteforceActive) {
						bruteForceCancelled = true;
					} else {
						startBruteforce();
					}
				}}
			>
				{bruteforceActive ? 'Stop' : 'Start'} Bruteforce
			</Button>

			<Tooltip>
				{#if demoPassword == ''}
					Generate a password before bruteforcing.
				{:else}
					If the predicted length is longer than 7 seconds, it is not recommended to bruteforce this
					password. This is a demonstration tool, not an efficient password cracker, and will likely
					crash your browser if pushed too far.
				{/if}
			</Tooltip>
		</ButtonGroup>
	</div>
	<!-- #endregion -->
	<!-- The elements enclosed below should only be visible if a benchmark has been run. -->
	{#if benchmarkRun}
		<div class="mx-auto w-fit">
			<Alert color="green" class="w-fit">
				<InfoCircleSolid slot="icon" class="h-4 w-4" />
				Your computer was able to generate and test {benchmarkGenerated} passwords in {benchmarkEndTime -
					benchmarkStartTime} milliseconds.
			</Alert>
		</div>
		<div class="mx-auto w-fit text-center">
			<P class="mb-6 w-fit text-lg dark:text-gray-400 sm:px-16" align="center"
				>With those results, your browser would take at worst {predictedRelevantTimeStat} to bruteforce
				your password. While obviously a dedicated password cracking machine would outperform your web
				browser, as you mess around with the settings it should be clear that with the exponentially
				increasing amount of possible passwords, the time to bruteforce also exponentially increases.</P
			>
			{#if bruteForceRun && !bruteForceCancelled}
				<div class="mx-auto w-fit text-center">
					<P class="mb-6 w-fit text-lg dark:text-gray-400 sm:px-16" align="center"
						>Your browser found the password "{demoPassword}" in {getRelevantTimeStat(
							bruteForceEndTime - bruteForceStartTime
						)}.</P
					>
				</div>
			{/if}
		</div>
	{/if}
</div>

<style>
</style>
